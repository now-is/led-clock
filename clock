#!/usr/bin/env lua

-- luarocks: lcurses sleep
local C = require 'curses'
local Enum = require 'enum'
local LED = require 'led'
local paint = require 'paint'
local sleep = require 'sleep'

local states = Enum({'running', 'paused'})
local state = states.running

local function rectangles_of (str, fill_char)
	local rectangles = {}
	local d
	for c in str:gmatch('.') do
		if c == ':' then
			d = LED.colon:gsub('%S', fill_char)
		else
			d = LED.digit(tonumber(c), fill_char)
		end
		if d ~= nil then
			rectangles[#rectangles+1] = d
		end
	end
	return rectangles
end

local _, digit_height = paint.dim(LED.digit(0, '@'))

-- positioning: tune to taste
local l_zero, c_zero, c_space = 8, 6, 6
local l_blips, c_blips = l_zero + digit_height + 3, c_zero

local blip, noblip, blip_stride = '@@@@@@', '      ', 3
local function update_blip (scr, sec, str)
	local c = c_zero + blip_stride*(sec - 1)
	if sec > 0 then
		scr:mvaddstr(l_blips, c, str)
		scr:mvaddstr(l_blips+1, c-1, str)
	end
end

C.initscr()
C.cbreak()
C.echo(false)

local scr = C.stdscr()
scr:nodelay(true)

local keys = {
	quit = string.byte('q')
}
local key

local sec0 = 60
while true do
	local sec1 = os.time() % 60
	if sec1 < sec0 then
		scr:clear()
		paint.rectangles(scr, l_zero, c_zero, rectangles_of(os.date('%H:%M'), '@'), c_space)
	else
		update_blip(scr, sec0, noblip)
	end
	update_blip(scr, sec1, blip)

	if state == states.running then
		scr:move(0, 0)
		scr:refresh()
	end

	key = scr:getch()
	if key == keys.quit then
		break
	end
	sec0 = sec1

	if state == states.running then
		sleep(1000)
	end
end

C.endwin()
